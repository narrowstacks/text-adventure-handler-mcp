"""FastMCP server for text adventure handler."""
import json
import uuid
from datetime import datetime
from pathlib import Path

from fastmcp import FastMCP
from fastmcp.resources import Resource

from .database import AdventureDB
from .models import Adventure, StatDefinition, WordList
from .dice import stat_check, roll_check
from .randomizer import get_random_word, generate_word_prompt, process_template

# Initialize FastMCP server
mcp = FastMCP("Text Adventure Handler MCP")
db = AdventureDB()


@mcp.tool()
def list_adventures() -> list[dict]:
    """List all available adventures with title and description."""
    return db.list_adventures()


@mcp.tool()
def start_adventure(adventure_id: str, randomize_initial: bool = True) -> dict:
    """
    Start a new game session.
    Returns session_id and initial game state.

    Args:
        adventure_id: The adventure to start
        randomize_initial: If True, substitute {word_list} placeholders in initial_location and initial_story
    """
    if not db.get_adventure(adventure_id):
        return {"error": f"Adventure {adventure_id} not found"}

    session_id = str(uuid.uuid4())
    if not db.create_session(session_id, adventure_id):
        return {"error": "Failed to create session"}

    session = db.get_session(session_id)
    adventure = db.get_adventure(adventure_id)

    # Process templates if randomization is enabled
    if randomize_initial:
        initial_location = process_template(adventure.initial_location, adventure)
        initial_story = process_template(adventure.initial_story, adventure)
        # Update session state with processed content
        session.state.location = initial_location
        db.update_player_state(session_id, session.state)
    else:
        initial_location = adventure.initial_location
        initial_story = adventure.initial_story

    return {
        "session_id": session_id,
        "title": adventure.title,
        "location": initial_location,
        "story": initial_story,
        "stats": session.state.stats,
        "score": session.state.score,
    }


@mcp.tool()
def get_state(session_id: str) -> dict:
    """Get current game state including location, stats, score, inventory."""
    session = db.get_session(session_id)
    if not session:
        return {"error": f"Session {session_id} not found"}

    return {
        "session_id": session_id,
        "location": session.state.location,
        "stats": session.state.stats,
        "inventory": session.state.inventory,
        "score": session.state.score,
        "custom_data": session.state.custom_data,
    }


@mcp.tool()
def take_action(session_id: str, action: str, stat_name: str = None, difficulty_class: int = 10) -> dict:
    """
    Perform an action. Optionally use a stat for a check.
    Returns success/failure, outcome, and score change.
    """
    session = db.get_session(session_id)
    if not session:
        return {"error": f"Session {session_id} not found"}

    # Perform dice check if stat is used
    if stat_name:
        if stat_name not in session.state.stats:
            return {"error": f"Stat '{stat_name}' not found in this adventure"}

        stat_value = session.state.stats[stat_name]
        roll_result = stat_check(stat_value, difficulty_class)
        success = roll_result.success
    else:
        roll_result = None
        success = True  # Non-stat actions always succeed but can have improv outcomes

    # Return action result (outcome would be generated by AI in real usage)
    return {
        "session_id": session_id,
        "action": action,
        "success": success,
        "dice_roll": roll_result.model_dump() if roll_result else None,
        "score_change": 10 if success else 0,
        "prompt": f"Generate a story outcome for this {'successful' if success else 'failed'} action: {action}",
    }


@mcp.tool()
def modify_stat(session_id: str, stat_name: str, value: int) -> dict:
    """Add to or set a player stat."""
    session = db.get_session(session_id)
    if not session:
        return {"error": f"Session {session_id} not found"}

    if stat_name not in session.state.stats:
        return {"error": f"Stat '{stat_name}' not found"}

    old_value = session.state.stats[stat_name]
    new_value = max(0, min(20, old_value + value))  # Clamp to 0-20
    session.state.stats[stat_name] = new_value
    db.update_player_state(session_id, session.state)

    return {
        "stat": stat_name,
        "old_value": old_value,
        "new_value": new_value,
        "change": value,
    }


@mcp.tool()
def roll_check(session_id: str, stat_name: str = None, difficulty_class: int = 10) -> dict:
    """Perform a stat check or plain d20 roll."""
    session = db.get_session(session_id)
    if not session:
        return {"error": f"Session {session_id} not found"}

    if stat_name:
        if stat_name not in session.state.stats:
            return {"error": f"Stat '{stat_name}' not found"}
        stat_value = session.state.stats[stat_name]
        result = stat_check(stat_value, difficulty_class)
    else:
        result = roll_check(difficulty_class=difficulty_class)

    return result.model_dump()


@mcp.tool()
def update_location(session_id: str, location: str) -> dict:
    """Move player to a new location."""
    session = db.get_session(session_id)
    if not session:
        return {"error": f"Session {session_id} not found"}

    session.state.location = location
    db.update_player_state(session_id, session.state)

    return {"location": location, "message": f"Moved to {location}"}


@mcp.tool()
def add_inventory(session_id: str, item: str) -> dict:
    """Add item to inventory."""
    session = db.get_session(session_id)
    if not session:
        return {"error": f"Session {session_id} not found"}

    if item not in session.state.inventory:
        session.state.inventory.append(item)
        db.update_player_state(session_id, session.state)

    return {"inventory": session.state.inventory}


@mcp.tool()
def remove_inventory(session_id: str, item: str) -> dict:
    """Remove item from inventory."""
    session = db.get_session(session_id)
    if not session:
        return {"error": f"Session {session_id} not found"}

    if item in session.state.inventory:
        session.state.inventory.remove(item)
        db.update_player_state(session_id, session.state)

    return {"inventory": session.state.inventory}


@mcp.tool()
def update_score(session_id: str, points: int) -> dict:
    """Add or subtract points from score."""
    session = db.get_session(session_id)
    if not session:
        return {"error": f"Session {session_id} not found"}

    session.state.score += points
    db.update_player_state(session_id, session.state)

    return {"score": session.state.score, "change": points}


@mcp.tool()
def get_history(session_id: str, limit: int = 20) -> dict:
    """Get action history for this session."""
    session = db.get_session(session_id)
    if not session:
        return {"error": f"Session {session_id} not found"}

    history = db.get_history(session_id, limit)
    return {"session_id": session_id, "history": history}


@mcp.tool()
def python_eval(session_id: str, code: str) -> dict:
    """
    Execute Python code for multi-step operations.
    Available in scope: session, state, db, stat_check, roll_check.
    Assign result to _result variable to return it.
    """
    session = db.get_session(session_id)
    if not session:
        return {"error": f"Session {session_id} not found"}

    # Create safe execution environment with limited builtins
    safe_builtins = {
        "len": len,
        "str": str,
        "int": int,
        "float": float,
        "list": list,
        "dict": dict,
        "max": max,
        "min": min,
        "sum": sum,
        "range": range,
        "enumerate": enumerate,
        "bool": bool,
        "isinstance": isinstance,
        "type": type,
    }

    namespace = {
        "__builtins__": safe_builtins,
        "session": session,
        "state": session.state,
        "db": db,
        "stat_check": stat_check,
        "roll_check": roll_check,
        "_result": None,
    }

    try:
        exec(code, namespace)
        # Persist state changes to database
        db.update_player_state(session_id, session.state)
        result = namespace.get("_result")
        return {
            "success": True,
            "result": result,
            "state": {
                "location": session.state.location,
                "stats": session.state.stats,
                "inventory": session.state.inventory,
                "score": session.state.score,
            },
        }
    except Exception as e:
        return {
            "error": f"Execution error: {str(e)}",
            "type": type(e).__name__,
        }


@mcp.tool()
def randomize_word(
    session_id: str,
    word_list_name: str,
    category_name: str = None,
    use_predefined: bool = True,
) -> dict:
    """
    Get a random word from adventure's predefined list or generate a prompt for AI.
    Returns either a word or a prompt for the AI to generate one dynamically.
    """
    session = db.get_session(session_id)
    if not session:
        return {"error": f"Session {session_id} not found"}

    adventure = db.get_adventure(session.adventure_id)

    if use_predefined:
        word = get_random_word(adventure, word_list_name, category_name)
        if word:
            return {
                "source": "predefined",
                "word": word,
                "word_list": word_list_name,
                "category": category_name or "all",
            }
        else:
            return {
                "error": f"Word list '{word_list_name}' not found",
                "available_lists": [wl.name for wl in adventure.word_lists],
            }
    else:
        prompt = generate_word_prompt(
            word_list_name,
            category_name,
            context=adventure.title,
        )
        return {
            "source": "ai_generated",
            "prompt": prompt,
            "word_list": word_list_name,
            "category": category_name or "any",
        }


@mcp.resource()
def adventure_prompt(adventure_id: str) -> Resource:
    """Get adventure prompt template for AI to generate story beats."""
    adventure = db.get_adventure(adventure_id)
    if not adventure:
        return Resource(uri=f"adventure://prompt/{adventure_id}", contents="Not found")

    prompt_content = f"""# {adventure.title}

## Description
{adventure.description}

## Story Prompt
{adventure.prompt}

## Available Stats
{json.dumps([{"name": s.name, "description": s.description, "range": f"{s.min_value}-{s.max_value}"} for s in adventure.stats], indent=2)}

## Initial Location
{adventure.initial_location}

## Instructions
Use this prompt to generate engaging story beats with multiple choices or allow for dynamic player improvisation. Keep track of stat checks and ensure actions have consequences."""

    return Resource(
        uri=f"adventure://prompt/{adventure_id}",
        contents=prompt_content,
        mime_type="text/plain",
    )


@mcp.resource()
def session_state(session_id: str) -> Resource:
    """Get session state in AI-readable JSON format."""
    session = db.get_session(session_id)
    if not session:
        return Resource(uri=f"session://state/{session_id}", contents="Not found")

    adventure = db.get_adventure(session.adventure_id)
    state_content = json.dumps({
        "session_id": session_id,
        "adventure": adventure.title,
        "location": session.state.location,
        "score": session.state.score,
        "stats": session.state.stats,
        "inventory": session.state.inventory,
        "custom_data": session.state.custom_data,
    }, indent=2)

    return Resource(
        uri=f"session://state/{session_id}",
        contents=state_content,
        mime_type="application/json",
    )


@mcp.resource()
def session_history(session_id: str) -> Resource:
    """Get full session action history."""
    session = db.get_session(session_id)
    if not session:
        return Resource(uri=f"session://history/{session_id}", contents="Not found")

    history = db.get_history(session_id, limit=100)
    history_content = json.dumps(history, indent=2, default=str)

    return Resource(
        uri=f"session://history/{session_id}",
        contents=history_content,
        mime_type="application/json",
    )


def load_sample_adventures():
    """Load adventures from JSON files in the adventures directory."""
    adventures_dir = Path(__file__).parent / "adventures"

    if not adventures_dir.exists():
        print(f"Warning: Adventures directory not found at {adventures_dir}")
        return

    for file_path in adventures_dir.glob("*.json"):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                adv_data = json.load(f)

            # Validate required fields (basic check)
            required_fields = ["id", "title", "description", "prompt", "stats", "word_lists", "initial_location", "initial_story"]
            if not all(key in adv_data for key in required_fields):
                print(f"Skipping {file_path.name}: Missing required fields")
                continue

            stats = [StatDefinition(**s) for s in adv_data.pop("stats")]
            word_lists = [WordList(**wl) for wl in adv_data.pop("word_lists")]
            adventure = Adventure(stats=stats, word_lists=word_lists, **adv_data)
            db.add_adventure(adventure)
            print(f"Loaded adventure: {adventure.title} ({adventure.id})")
        except Exception as e:
            print(f"Error loading adventure from {file_path.name}: {e}")
